---
title: 技术备忘
date: '2020-11-30 20:35:55'
tags: 
- Summary

draft: 1

category: Development
image: 
---

## React渲染细节

- Portal将子节点渲染到父组件以外的DOM节点，在DOM树中子节点位于被渲染到的节点子树中，而在React树中，子节点依然位于原本父节点子树中而与其在DOM树中的位置无关，因此其触发事件会沿着React树进行传递。React官网中Portal实例：

```javascript
// 在 DOM 中有两个容器是兄弟级 （siblings）
const appRoot = document.getElementById('app-root');
const modalRoot = document.getElementById('modal-root');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }

  componentDidMount() {
    // 在 Modal 的所有子元素被挂载后，
    // 这个 portal 元素会被嵌入到 DOM 树中，
    // 这意味着子元素将被挂载到一个分离的 DOM 节点中。
    // 如果要求子组件在挂载时可以立刻接入 DOM 树，
    // 例如衡量一个 DOM 节点，
    // 或者在后代节点中使用 ‘autoFocus’，
    // 则需添加 state 到 Modal 中，
    // 仅当 Modal 被插入 DOM 树中才能渲染子元素。
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}
```

- render()的返回值可以为：React元素、数组\Fragments、Portals、字符串或数值（直接渲染为文本节点）以及布尔类型。
  

## React渲染原理

通过JSX模板根据state和prop数据生成js对象虚拟DOM，再通过render()生成真实DOM，当state和prop数据发生变化时通过模板生成新的虚拟DOM并通过diff函数比较原始虚拟DOM和新虚拟DOM的区别找到DOM内容的变化并直接操作DOM改变其内容。

- createElement()从JSX模板中获取DOM标签、内容和属性生成ReactElement实例对象，虚拟Element彼此嵌套构成Virtual dom树。
- ReactDOM.render()接受一个ReactElement对象和一个作为容器的DOM节点作为参数，首先通过instantiateReactComponent()实例化React组件，其可以为空组件、DOM标签、自定义组件或文本。ReactComponent类包含props、context、refs、updater属性和setState()、forceUpdate()的原型方法；之后通过mountComponent()批量装载到DOM。
- 组件首次挂载：componentWillMount()->render()->componnetDidMount()
- 组件更新重新渲染：componentWillReceiveProps(getDerivedStateFromProps)->shouldComponentUpdate()->componentWillUpdate()->render()->componentDidUpdate()
- React diff算法的三个策略使得：DOM节点的跨节点操作会直接导致节点的删除并重新渲染；同一层级的子节点通过唯一的key来区分，不设置会影响对比的性能，而使用数组索引作为key将导致数组发生变化时列表出现与期望不符的变化。
- 同级节点的比较过程中：对新集合节点进行循环遍历，如果新集合中当前访问的节点比 lastIndex（访问过的新节点在旧DOM中的最大索引值） 大，证明当前访问节点在旧集合中比上一个节点的位置靠后，则该节点不会影响其他节点的位置，即不进行移动操作。只有当前访问节点比 lastIndex 小的时候，才需要进行移动操作。出现旧节点中没有的节点时需要插入新节点，而遍历结束后还需要遍历旧节点，删除不存在与新DOM中的节点。

## React性能优化

- 减少diff算法调用（减少update）：setState()（在非批更新阶段setTimeOut/Promise减少调用）、父组件render()(使用PureComponent，尽量使用绑定函数、常量作为prop防止生成新对象)、减少使用forceUpdate()）
- 理解diff算法：不使用跨层级节点移动（可以通过Portal进行跨节点渲染）；条件渲染多个节点时使用隐藏而不是替换节点；尽量避免将后面的子节点向前移动。

React.PureComponent和React.memo()都是在Component的基础上实现了默认的shouldComponentUpdate()函数，即通过对state和props进行浅比较（shallow compare）来避免不必要的组件重新渲染。然而setState检测state是否发生变化的方法也是使用浅比较，为了使array数据项的变更触发state变更又要避免全部列表触发SCU，可以使用Immutable Data来进行声明。避免深拷贝吧所有节点都复制一遍带来的性能消耗，Immutable 使用了结构共享，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。

setState()的运行机制
[setState源码解析](https://cloud.tencent.com/developer/article/1592636)

